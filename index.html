<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Portrait Camera Capture</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #000;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
        color: #fff;
      }

      .app {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        height: 100vh;
        padding: 12px 12px calc(env(safe-area-inset-bottom, 0px) + 12px);
        box-sizing: border-box;
        gap: 12px;
      }

      .preview-wrapper {
        position: relative;
        flex: 1;
        width: 100%;
        max-width: 600px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        border-radius: 12px;
        background: #111;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(1); /* no mirror for rear camera */
      }

      .controls {
        display: flex;
        gap: 12px;
        width: 100%;
        max-width: 600px;
        justify-content: space-between;
        align-items: center;
      }

      button {
        flex: 1;
        padding: 12px 16px;
        font-size: 16px;
        border-radius: 999px;
        border: none;
        background: #0d6efd;
        color: #fff;
        cursor: pointer;
        font-weight: 600;
      }

      button:disabled {
        opacity: 0.5;
        cursor: default;
      }

      .info {
        font-size: 12px;
        opacity: 0.75;
        text-align: center;
        max-width: 600px;
      }

      a#download {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="preview-wrapper">
        <video id="preview" playsinline autoplay></video>
      </div>

      <div class="controls">
        <button id="capture" disabled>Capture portrait</button>
      </div>

      <div class="info">
        Capture uses the highest camera resolution available, then scales and
        crops into a portrait image (1080 Ã— 1920) before download (portrait).
        The full raw camera frame is also downloaded so you keep an unmodified
        copy.
      </div>

      <a id="download"></a>
    </div>

    <script>
      const video = document.getElementById('preview');
      const captureBtn = document.getElementById('capture');
      const downloadLink = document.getElementById('download');

      async function startCamera() {
        try {
          const constraints = {
            video: {
              facingMode: 'environment',
              width: { ideal: 4096 },
              height: { ideal: 2160 },
              frameRate: { ideal: 30 },
            },
            audio: false,
          };

          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          
          // Log the actual resolution we got and camera capabilities
          const track = stream.getVideoTracks()[0];
          const settings = track.getSettings();
          const capabilities = track.getCapabilities();
          
          console.log(`Camera resolution: ${settings.width}x${settings.height}`);
          console.log('Camera capabilities:', capabilities);
          console.log('Current settings:', settings);

          video.onloadedmetadata = () => {
            captureBtn.disabled = false;
          };
        } catch (err) {
          console.error('Error starting camera:', err);
          alert('Could not access camera: ' + err.message);
        }
      }

      function capturePortrait() {
        if (!video.videoWidth || !video.videoHeight) return;

        // Fixed portrait output
        const targetWidth = 1080;
        const targetHeight = 1920;

        const canvas = document.createElement('canvas');
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext('2d');

        const vw = video.videoWidth;
        const vh = video.videoHeight;

        // Assume the video frame is already visually upright.
        // Just scale to fill the portrait canvas and center, preserving aspect.
        const scale = Math.max(targetWidth / vw, targetHeight / vh);

        const drawW = vw * scale;
        const drawH = vh * scale;
        const dx = (targetWidth - drawW) / 2;
        const dy = (targetHeight - drawH) / 2;

        ctx.drawImage(video, dx, dy, drawW, drawH);

        canvas.toBlob(
          (blob) => {
            if (!blob) return;
            const url = URL.createObjectURL(blob);
            downloadLink.href = url;
            // Use a lossless image format for maximum fidelity.
            // PNG is widely supported and will preserve exact pixel data from the canvas.
            downloadLink.download = 'capture-portrait-1080x1920.png';
            downloadLink.click();
            setTimeout(() => URL.revokeObjectURL(url), 5000);
          },
          // Use PNG (lossless) to preserve maximum fidelity.
          'image/png'
        );
      }

      // helper to trigger a download for a Blob using an anchor. Uses a temporary
      // object URL and revokes it shortly after.
      function downloadBlob(blob, filename) {
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        // Click the anchor to initiate download. This is allowed because this
        // function is called inside a user-initiated event (click).
        document.body.appendChild(a);
        a.click();
        a.remove();
        // Revoke URL after a short delay to allow download to start.
        setTimeout(() => URL.revokeObjectURL(url), 5000);
      }

      // Capture both the cropped portrait and the raw full-frame image.
      async function captureBoth() {
        if (!video.videoWidth || !video.videoHeight) return;

        // --- portrait capture (existing behavior) ---
        const targetWidth = 1080;
        const targetHeight = 1920;
        const portraitCanvas = document.createElement('canvas');
        portraitCanvas.width = targetWidth;
        portraitCanvas.height = targetHeight;
        const pctx = portraitCanvas.getContext('2d');

        const vw = video.videoWidth;
        const vh = video.videoHeight;
        const scale = Math.max(targetWidth / vw, targetHeight / vh);
        const drawW = vw * scale;
        const drawH = vh * scale;
        const dx = (targetWidth - drawW) / 2;
        const dy = (targetHeight - drawH) / 2;

        pctx.drawImage(video, dx, dy, drawW, drawH);

        // --- raw full-frame capture ---
        const rawCanvas = document.createElement('canvas');
        rawCanvas.width = vw;
        rawCanvas.height = vh;
        const rctx = rawCanvas.getContext('2d');
        // draw the current video frame at full resolution into the raw canvas
        rctx.drawImage(video, 0, 0, vw, vh);

        // Convert both canvases to PNG Blobs and download them.
        // Doing these asynchronously keeps the UI responsive.
        // portraitCanvas.toBlob((pblob) => {
        //   if (pblob)
        //     downloadBlob(
        //       pblob,
        //       `capture-portrait-${targetWidth}x${targetHeight}.png`
        //     );
        // }, 'image/png');

        rawCanvas.toBlob((rblob) => {
          if (rblob) downloadBlob(rblob, `capture-raw-${vw}x${vh}.png`);
        }, 'image/png');
      }

      captureBtn.addEventListener('click', captureBoth);
      startCamera();
    </script>
  </body>
</html>
